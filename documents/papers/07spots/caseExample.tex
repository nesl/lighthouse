\section{Examples of Resource Tracking}
\label{sec:example}

We now explore resorce usage within sensor network operating systems using two
different case examples: buffer swapping within {\tt GenericBaseM} from TinyOS
and dynamic memory management in {\tt surge} from SOS.

\subsection{Resource usage in Sensor Networks}

\smallskip\noindent{\bf Resource usage in {\tt GenericBaseM}}

\begin{figure}[t]
\input{GenericBaseM.c}
\caption{TinyOS implementation of {\tt GenericBaseM receive
interface}\label{fig:genericbase}}
\end{figure}


Figure~\ref{fig:genericbase} shows a portion of the TinyOS component
that implements the {\tt receive} event handler for {\tt
GenericBaseM}, an application that uses a sensor node as a bridge
between a base station and the rest of a sensor network.  The
\code{receive} event handler is passed in a \code{TOS\_MsgPtr}
pointing to the incoming message and a flag describing the message
source.  If there are no messages waiting to be sent, the handler
forwards the message out over the bridged interface and returns a
pointer to a free message buffer.  If a message is currently pending,
the handler simply ignores the message and returns the incoming
message buffer to be reused.

A key property demonstrated by this TinyOS component is that of buffer
swapping.  Buffer swapping is a common technique used within TinyOS to
allow data to quickly pass through stacks of components.  Rather than
dynamically allocating a new buffer, a call stack can simply return a
free buffer (out of a pool of statically allocated buffers) to the
caller.  In the TinyOS environment, handlers that implement buffer
swapping have implicit memory ownership responsibilities.  The handler
can be thought of needing to claim the incoming \code{TOS\_MsgPtr} and
release a buffer to the caller.  Note that this can be accomplished by
returning the incoming buffer.


\smallskip\noindent{\bf Resource usage in {\tt surge}}

\begin{figure}[t]
\input{surge.c}
\caption{SOS implementation of {\tt surge}\label{fig:surge}}
\end{figure}

Figure~\ref{fig:surge} shows a portion of the SOS module that
implements {\tt surge}, a simple sensor network application that takes
sensor readings and sends the readings over a multihop network to a
base station~\cite{nesC}.  The module's persistent state and an
incoming message are passed to the \code{surge\_module} function,
which uses a \code{switch} statement to dispatch the message to a
specific handler.  The \code{MSG\_DATA\_READY} handler causes a new
message to be created with the most recent sensor data, encapsulated,
and sent out via a tree routing mechanism.  The
\code{MSG\_TR\_DATA\_PKT} handler is exeucted at the root of a data
routing tree when a data message arrives, and takes control of the
incoming encapsulated message so that it can be forwarded over a UART.

%%
% ROY: 11/7/06 I condensed the following three paragarphs into the
% more concise description provided above.
%%

% The \code{surge\_module} function is the
% entry point into {\tt surge} for messages from the kernel and from
% other modules.  The function takes two arguments: a pointer to the
% module's persistent state, which is saved in the kernel, and a pointer
% to the current message.  A {\tt switch} statement is used to direct
% each message type to an appropriate handler.  The handlers of interest
% in this example are for the messages types {\tt MSG\_DATA\_READY} and
% {\tt MSG\_TR\_DATA\_PKT}.
% 
% A sensor sends the message {\tt MSG\_DATA\_READY} to the surge module
% when requested sensor data is ready to be read. The sensor data is
% passed as the {\tt data} field of the message, which in general always
% contains a message's payload.  Upon receiving this message, the {\tt
% surge} message handler allocates a new packet ({\tt ker\_malloc}) to
% be sent to the base station and posts a message ({\tt post\_long}) to
% the tree-routing module in order to forward the sensor data.  The {\tt
% post\_long} call is asynchronous, causing the kernel to package up all
% the given arguments into a {\tt Message} structure and to schedule
% this message for eventual delivery.
% 
% The message {\tt MSG\_TR\_DATA\_PKT} is sent by the tree-routing
% module when data is received at the base station node.  Upon receiving
% this message, the {\tt surge} message handler confirms that the
% current node is the base station.  If so, the message handler forwards
% the data to the UART driver via an asynchronous message send ({\tt
% post\_net}).

The SOS kernel provides an API for programmers to manage dynamic
memory.  
%As shown in Figure~\ref{fig:surge}, 
Functions such as \code{ker\_malloc} and \code{ker\_free} are used to
dynamiclly creat and destroy data memory buffers.  Additionally,
ownership of dynamic memory can be transferred between modules using
the \code{post\_*} and \code{ker\_msg\_take\_data} interfaces.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Improper Resource Management}

The ability to manipulate resources demonstrated above results in
small and effecient programs well suited for the embedded processors
used within sensor networks.  However, improper resource management
can cause serrious problems for sensor network applications.


\smallskip\noindent{\bf Potential problems with {\tt GenericBaseM}}

The \code{recieve} interface implemented in {\tt GenericBaseM}, and in
other end user components that recive messages, depends on proper use
of buffer swapping.  Problems arise if a component attempts to store a
pointer to the incomming buffer for latter access and then returns a
pointer to that same buffer, as would be the case if if line 10 were
left out of figure~\ref{genericbase}.  In this situation two different
components now have references to a buffer that each component belives
it has exclusive access to.  Or if a TinyOS component should return a
fresh buffer and fail to creat a persistent reference to the incomming
buffer, buffers would be leaked.  In figure~\ref{genericbase} this
could happen if line 02 were ommitted.  Added confusion arrises in
more complex code, such as the \code{if} statement at line 06 in {\tt
GenericBaseM}, that returns different buffers depending on specific
conditions. 


\smallskip\noindent{\bf Incorrect versions of {\tt surge}}

SOS development runs into similar difficulties with its dynamic
memory.  Leaking memory is a problem in all systems that allow dynamic
memory creation.  This would occure in {\tt surge} if the
\code{SOS\_MSG\_RELEASE} flag were left out of the call to
\code{post\_net} on line 23 of figure~\ref{surge}.  Further, tricky
dangling pointer would result from forgetting to claim ownership of
the incoming data before it is sent out over the UART at line 20 of
figure~\ref{surge}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Static Ownership Checking}

In this work, we augment the often implicit ownership directives in
sensor network operating systems to provide a protocol governing
memory management that is sufficient to ensure the absence of memory
errors.  Our protocol makes explicit a common programming idiom in
sensor-network systems, whereby data is rarely shared but instead
follows a producer/consumer model.  
%
Informally, the rules of the protocol can be stated as follows:
%
\begin{itemize}
%
\item A module may only manipulate the memory that it owns.
%
\item A module that takes ownership of a block of memory (either
through a function that allocates data or via a transfer of ownership)
must either free that memory, release it, or store it in the module's
persistent state.
%
\item A module may only free or release memory that it owns.  After a
module frees or releases memory, it may not access or update that
memory.
%
\end{itemize}
%
Since only the owner can manipulate or free a resource, accessing
``dangling'' resources is avoided.  Because each resource must be
either freed, released or persistently stored by its owner, resource 
leaks are avoided.  
%
Following these basic rules prevents the problems described above.



\smallskip\noindent{\bf Applying Ownership Protocol to {\tt GenericBaseM}}


Similarly, the {\tt GenericBaseM} module follows the
ownership protocol. Upon entry to the {\tt receive}
event handler the {\tt GenericBaseM} component owns the buffer
referenced by the global variable {\tt ourBuffer} and gains ownership
of the {\tt received} buffer passed into the function.  Within the
body of the function the handler, these are the only two buffers
accessed, although they are at times accessed via the alias {\tt
nextReceiveBuffer}.  At the end of the handler the buffer aliased by
{\tt nextReceiveBuffer} is returned to the calling function.  Note
that regardless of the path taken through the handler, at the 
return point, the returned buffer (pointed to by {\tt nextReceiveBuffer})
is distinct from the buffer persistently
stored in {\tt ourBuffer}.  Thus the returned buffer is not accessed
by this component after the return.





\smallskip\noindent{\bf Applying Ownership Protocol to {\tt surge}}

Transfer of dynamic memory ownership occurs at the end points of a
message.  First, the owner of a block of dynamically allocated memory
can explicitly {\em release} ownership of that block when it is passed
as the payload in a message.  This is accomplished by setting the
\texttt{SOS\_MSG\_RELEASE} flag in the corresponding {\tt post\_*}
call.  For example, the {\tt surge} module releases ownership of the
newly allocated {\tt pkt} upon sending it to the tree-routing module.
Second, a module can acquire ownership of a message's payload, which
is stored in the {\tt data} field, by calling
\texttt{ker\_msg\_take\_data} on an incoming message.  The function
returns a pointer to the message's payload.  For example, if the
current node is the base station, the {\tt surge} module explicitly
takes ownership of the given message's data under the name {\tt
payload}.

There are four release/take scenarios to consider.  If data is both
released by its sender and taken by its receiver, then ownership of
the data is transferred from the sender to the receiver.  If data is
released by its sender but not taken by its receiver, then the kernel
automatically frees the memory after the receiver's message handler
completes.  If data is not released by its sender but is taken by its
receiver, then the sender keeps ownership of the original message and
the receiver gains ownership of a new block of memory containing a
copy of that data.  Finally, if the data is not released by the sender
and not claimed by the receiver, then the sender keeps ownership of
the original message and the receiver has direct access to
``borrowed'' data for a limited period of time.  This last case is not
generally used in SOS due to the synchronization complications that
can result.

%%
% ROY: 10/18/06 This is not adding much to the discussion.
%%

% In order to provide a simple form of automatic garbage collection for
% dynamically allocated memory, the SOS kernel imposes an {\em
% ownership} model on dynamic memory~\cite{sos}.  Each block of memory
% has a unique owner at any point in time, and the kernel maintains a
% mapping from each block of memory to its owner.  A block's initial
% owner is the module that allocates that block.  For example, the call
% to {\tt ker\_malloc} sets the {\tt surge} module as the initial owner
% of the newly allocated block.  When a module is removed from the
% system at run time, the kernel automatically frees all memory owned by
% that module.
%
% Simple garbage collection introduces the potential for more
% dangling pointer errors, since the removal of a module implicitly
% frees the memory it owns, even if other modules have pointers to
% that memory.



The {\tt surge} module described above can be shown to adhere to this
ownership protocol.  The {\tt MSG\_DATA\_RDY} message handler
allocates {\tt pkt} and takes ownership. This pointer is then
dereferenced in order to provide the sensor data to be sent up the
routing tree.  This pointer manipulation is safe since the module has
ownership.  The module then releases ownership by posting {\tt pkt} to
the tree routing module using the {\tt SOS\_MSG\_RELEASE} tag.  After
this release, the module does not access {\tt pkt} again and does not
store it, ensuring that access to the pointer is indeed released. 

The handler for {\tt MSG\_TR\_DATA\_PKT} also conforms to the
protocol.   When the current node is the base station, the handler
explicitly acquires ownership of the message's data using {\tt
ker\_msg\_take\_data}.  This allows the module to manipulate the data
and to pass it to the UART.  The {\tt post\_net} call explicitly
releases the data, fulfilling the module's obligation to that data.
After the release, the data is no longer accessed or stored.

While the {\tt surge} code is correct, small changes to the code can
easily cause problems to occur at run time, and our static checker
catches these potential errors.  
For example, suppose the handler for
{\tt MSG\_DATA\_READY} did not release ownership of {\tt pkt} by
setting the {\tt SOS\_MSG\_RELEASE} flag in the call to {\tt
post\_long}.  In that case, the module would leak the memory allocated
for {\tt pkt}.  Indeed, our checker flags this modified version of the
code as erroneous, since {\tt surge} would not be freeing, releasing,
or storing the data for which it has taken ownership.


