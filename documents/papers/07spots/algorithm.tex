\section{Analysis Specification and Implementation}
\label{sec:alg}

Motivated by the observation that a simple ownership protocol can be
used to reason about proper resource usage common to sensor networks,
we developed Lighthouse to look for violations of this protocol within
SOS code.  Lighthouse checks two key properties relating to resources:
No resource should be leaked, and there should be no dangling
pointers.  More precisely:

\smallskip\noindent {\bf No Leaks.} This first property defines the
absence of resource leaks by enforcing that along every program
execution path, every allocation is necessarily followed by either a
free or a store of a handle that refers to the same resource that was
just allocated.

\smallskip\noindent {\bf No Dangling Pointers.} The second property
states that once a resource has been freed, it is never accessed
again.

We now explain how these two properties are checked using the
Lighthouse tool, and mention some of the limitations of our implementation.


\subsection{Implementation}

Lighthouse checks programs at compile time for violations of the above
two properties.  The tool performs a static dataflow analysis for each
property on a program's control-flow graph (CFG), which statically
represents all possible execution paths.  

For the SOS instantiation the $\mathrm{alloc}$ and $\mathrm{free}$
operations are respectively represented by {\tt ker\_malloc} and {\tt
ker\_free}.  To identify a module's persistent state in SOS, we
provide a new attribute {\tt lh\_store} for formal parameters.  For
example, the {\tt state} argument to a module's event handler would be
annotated with this attribute.  This is required since SOS modules are
passed in a reference to their persistent state, rather than directly accessing a
global variable.

Our dataflow analyses are implemented in the CIL front end for
C~\cite{CIL}, which parses C code into a simple intermediate format
and provides a framework for performing analyses on the intermediate
code.  Each analysis is {\em modular}, considering each module
independently and analyzing the CFG for each procedure within the
module in isolation.  Care must be taken that our static checker
conservatively approximate the dynamic conditions that must be
satisfied.  Two notable issues are the treatment of pointer aliasing
and of procedure calls, which we discuss in turn.

\smallskip\noindent
{\bf Pointer Aliasing.}
First, the invariants described above depend on dynamic alias
information, which cannot be exactly computed at compile time.
Instead, two standard approximations are {\em must-alias} analysis and
{\em may-alias} analysis.  A must-alias analysis underapproximates the
dynamic alias relations:  if a must-alias analysis determines that $x$
and $y$ alias at a particular program point, then $\alias(x,y)$
definitely holds at any run-time execution state corresponding to that
program point.  A may-alias analysis overapproximates the dynamic
alias relations:  if a may-alias analysis determines that $x$ and $y$
{\em cannot} alias at a particular program point, then $\alias(x,y)$
definitely does not hold at any run-time execution state corresponding
to that program point.

Our checker requires both kinds of static alias approximations.  In
the first property described above, alias information is used to
ensure that something definitely happens, namely that an allocated
resource is eventually freed.  Therefore, in this case we approximate
the true alias information with must-alias information.  In the second
property described above, alias information is used to ensure that
something definitely does not happen, namely an access to a freed
resource.  Therefore, in this case we approximate the true alias
information with may-alias information.

Our implementation currently uses a simple flow-sensitive must-alias
analysis.  For the may-alias analysis, we use a fast flow-insensitive
alias analysis provided by the CIL framework.  It should be noted that 
static alias analysis
can be imprecise in the presence of complex pointer
manipulations and pointer structures.  For example, CIL's may-alias
analysis does not distinguish among the fields of a structure, instead
considering them to always potentially alias one another.  This does not
effect the correctness of the analysis in Lighthouse, but rather causes an overly 
conservative analysis that may trigger false positives in some situations.

\smallskip\noindent
%
{\bf Modular Analysis.}
%
Our analysis is {\em modular}:  each function in a module or component
is analyzed in isolation.  To make checking of a function body precise
in the presence of calls to other functions, we employ {\em ownership
attributes} for function headers that capture the memory-related
behavior of a called function.  We add two attributes to the C code:
{\tt lh\_claim} and {\tt lh\_release}.  A formal parameter or return
value that has the {\tt lh\_claim} attribute indicates that the caller
must take ownership of the associated memory after a call.  This
annotation, for example, would be used to annotate a function that
wraps a call to {\tt ker\_malloc} within SOS, allowing that function's
callers to be properly checked without access to the function's
implementation.  Similarly, an {\tt lh\_release} attribute on a formal
parameter indicates that ownership of the parameter is transferred
from the caller of the function to the callee.  
%
% If a parameter does not have an ownership attribute, memory
% ownership is unchanged.  Lighthouse ensures that these attributes
% are employed wherever necessary, when checking the implementation of
% each function.  
%
Lighthouse ensures that parameters with these attributes properly
follow the ownership protocol within the body of the function.
%
In practice, we have found that a small set of annotations is
sufficient for precise analysis.

Given such attributes, the proper handling of procedure calls becomes
straightforward.  A procedure call statement is treated logically by
the checker as an assignment from actuals to formals, followed by an
assignment from the return value of the call to the left-hand-side
variable (if any).  A formal parameter annotated with the {\tt
lh\_claim} attribute is treated as an allocation site, just as is {\tt
ker\_malloc}.  A formal parameter annotated with the {\tt lh\_release}
attribute is treated as a disposal site, just as is {\tt ker\_free}.

The ability to perform checking modularly allows application writers
to obtain early feedback about the correctness of their resource
management, without requiring access to the rest of the system.  This
is particularly important in a system like SOS, in which modules can
be linked and unlinked dynamically.  In such a setting, the ``rest''
of the system is a moving target, so it is not really possible to
consider whole-program analysis.



\subsection{Limitations}

As we demonstrate in the next section, our checker is useful for
detecting violations of the ownership protocol on real sensor network
code.  However, the checker is not guaranteed to find all such
violations.  In other words, the checker can be used for finding
memory errors but not for guaranteeing the absence of all memory
errors.  We discuss three limitations of the checker in this regard.

First, the checker does not precisely handle all of the unsafe
features of the C programming language.  For example, pointer
arithmetic is not statically analyzed.  Instead, an expression of the
form $p+i$, where $p$ is a pointer and $i$ is an integer, is simply
treated as if it refers to the same block of memory as $p$.  If $p+i$
in fact overflows to another block of memory at run time, the
checker's assumption can cause it to miss errors.  These kinds of
limitations are standard for C-based program analyses.

Second, there is a design choice about how to treat resources that a
handler does not explicitly acquire through an interface that is
annotated with {\tt lh\_claim} and {\tt lh\_release}.  Technically the
ownership protocol disallows these resources from being accessed at
all, since the receiving module is not the owner.  
%
Lighthouse does not currently enforce this requirement that a module
only access a resource that it owns.
% 
This allows new systems using Lighthouse to incrementally add
annotations to iterativly refine the quality of the analysis without
suffering from excessive numbers of false positives.
%
Further, this provides a mechanism for allowing patterns of resource
sharing that are in fact safe but not allowed by the ownership
disciplin, for example when a module temporarily ``borrows'' data from
another module within a bounded scope.
%
But it does introduce the potential of missing real errors due to
missing annotations.
%
Regardless, the checker still ensures that a handler does not access a
resource that has earlier been freed or released.


Finally, our modular checker does not consider the overall order in
which messages will be received.  However, there may be
application-level protocols that determine how events are generated in
the system, and these protocols can affect the correctness of
ownership tracking when a resource is placed in or accessed from a
persistent store.
%
For example, imagine a module that responds to three events: $\create$
causes the module to allocate a block $b$ and store it into the
module's persistent store, $\access$ causes the module to access block
$b$ via the  store, and $\delete$ causes the module to deallocate
block $b$ in the store.  The module properly manages block $b$ as
long as the temporal sequence of events follows the regular expression:
$($ $\alloc$ $\access^*$ $\delete$ $)^*$.  This ordering ensures that the system
never accesses the block before it is allocated and always eventually
deletes the block.
%
However, Lighthouse currently only tracks data locally within each event handler.
When performing this tracking, the tool assumes on entry that all data
in the persistent store is owned by the module.  The tool similarly
considers a resource to be properly released when it is placed in the
persistent store.  These assumptions can miss errors, for example if
an $\access$ event ever occurs before the $\alloc$ event.  However,
our assumptions provide a practical point in the design space that
allows each event handler to be usefully checked for local violations
of the ownership protocol.
Handling these inter-module relationships and application-level
protocols is something we are interested to include in our future
work~\cite{AlurPOPL05,HJM05}.

