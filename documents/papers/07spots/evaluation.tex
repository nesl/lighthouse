\section{Evaluation}
\label{sec:eval}

This evaluation examines to what extent this type of tool is needed
within the sensor network community and how effetive it is at
isolating problems within sensor network systems.  Our evaluation
focused on the SOS operating system, using the public CVS archives to
supply programs for analysis.  SOS applications are made up of small
user modules that can be combined into larger programs.  These modules
run ontop of a well defined kernel and are developed using an API
supplied by this kernel.


\subsection{Quantifying Dynamic Memory Usage in SOS}

Of interest is the prevalence of dynamic resource management within
sensor network systems.  TinyOS displays this through buffer swapping
within messaging stacks and more general message queues.  Within SOS
this is seen through memory buffer management.  

Focusing on SOS, we quantify the usage of operations that manipulate
memory ownership within the SOS operating system.  The SOS API
includes a number of functions that manipulate memory.  These
functions are used to allocate, free, and transfer ownership of blocks
of memory.  

The CVS head from October 2006 reveals 36 modules totaling 5824 lines
of source code.  Within this sample there are 178 lines of code
calling a function that manipulates memory, or one such function call
for every 32 lines of code.  Looking at all historic version of all
SOS modules reveals that this frequency has not changed signifacntly
over time.  These findings indicate that memory management has been
and continues to be an important part of resource management in SOS.


\subsection{Validating SOS End-User Modules}

Two additional questions arise as a result of the observation that
memory is frequentnly manipulated as a resource in SOS.  These
questions are:
%
\begin{itemize}
%
\item Do programers have problems properly using the resource
managment?
%
\item Would the analysis described in this paper help with
those problems?
%
\end{itemize}

To address these questions we ran our tool on all versions of all SOS
end-user modules contained within the CVS repository to demonstrate
how it would fit into an everyday development cycle.  For this
analysis, we only consider the first occurrence of a particular bug
withing a program, even if the bug lasts through multiple consecutive
versions of a particular module.  We applied the checker to every
historic version of each user module included in the SOS CVS
repository that would compile for the \code{mica2} target.  The 48
available modules resulted in a total of 213 unique versions.
%
An external configuration of 24 function annotations was used for this
analysis.  
%
Additionally, local store annotations were added to 9 module versions
and a change to the core SOS API from the summer of 2006 required
changing the value of a constant in 6 module versions.


\begin{table}
\caption{Warnings in SOS user modules}
%
\label{tab:module}
\centering 
\begin{tabular}{| l | r |}
    \hline 
    Verified memory leaks identified by analysis & 8 \\
    \hline
    False memory leaks identified by analysis & 8 \\
    \hline 
    Verified dangling pointers identified by analysis & 0 \\
    \hline 
    False dangling pointers identified by analysis & 9 \\
    \hline 
\end{tabular} 
%
\end{table}

Of the 213 modules analyzed, 13 of the modules generaed warnings for a
total of 25 warnings.
%
Each warning was examined by hand and classified as an actual error or
a false positive; the results are presented in Table~\ref{tab:module}.  
%
Eight of the warnings turned out to be real memory leaks in the code.
%
The 17 remaining warnings were further classified to better understand
the sources of imprecision in the current implementation of the
checker.  

\smallskip\noindent{\bf Memory leak false positives.}

False positives from memory leaks came from two different sources.
Five of the false positives resulted from a conservative assumption
made by the must alias analysis used within the checker.  The analysis
assumes that functions can change what data is referenced by a formal
parameter.  This results in required must alias information being lost
in these cases.  The analysis can easily rank these as probable false
positives if the end user wishes to see more likely errors first.  The
other three memory leaks are the result of linked list data structures
that the must alias analysis is unable to properly reason about.  

\smallskip\noindent{\bf Dangling pointer false positives.}

The nine dangling pointer false positives result from limitations of
the flow-insensitive and field-insensitive may analysis.  Elimination
of these false positives would require a more accurate may analysis.
Modern sensor network applications are made of small components that
effecivly limit the scope of variables.  This opens the door to using
context sensitive analysis that suffer from scaling limitations in
more general domains.


\subsection{Validating the SOS Kernel}

\begin{table}
\caption{Warnings in the SOS kernel}
%
\label{tab:kernel}
\centering 
\begin{tabular}{| l | r |}
    \hline 
    Verified memory leaks identified by analysis & 2 \\
    \hline
    False memory leaks identified by analysis & 22 \\
    \hline 
    Verified dangling pointers identified by analysis & 0 \\
    \hline 
    False dangling pointers identified by analysis & 11 \\
    \hline 
\end{tabular} 
%
\end{table}


We ran a similar experiment on all code required to build the core the
SOS kernel for the \code{mica2} target.  This configuration consists
of approximately 9000 lines of source code and required analyzing 40
source files, of which 35 generated warnings.  A detailed breakdown of
these warnings is provided in table~\ref{tab:kernel}.

\mynote{ROY: This paragraph is very awkward.  It needs to be
rephrased.} 
%
The two actual memory leaks represent an interesting type of error.
These leaks resulted from functions that released a formal parameter,
except in exceptional cases where an error code is returned to the
user.  It is more accurate to say that these functions do not leak
memory, but rather conditionally release memory.  However user code
treats these functions as unconditional releases, not bothering to
check the return vaules.  Since changing these two functions would
result in a number of errors in user code, we assumed that the two
kernel functions are incorrect.

A second point of interest is the different rates of false positives
reported for user modules and for the kernel.  User modules resulted
in approximately one false positive for every 1650 lines of source
code.  The kernel saw a much higher frequency at approximately one 
false positive for every 270 lines of source code.  

A large contributor to this increased rate of false positives within
the kernel are the bottom layer functions implementing management of
memory in SOS.  These functions manipulate memory in a manner that
does not conform to the model assumed for the analysis.  For example,
the function \code{ker\_msg\_take\_data} is annotated to denote that
it returns dynamically allocated memory, but the analysis warns that
no such memory is returned.  This is because the function directly
accesses the internal data structures of the SOS memory manager to
return a pointer to dynamically allocated data, rather than using an
annotated interface such as \code{ker\_malloc}.
%
\mynote{ROY: What is the point of this paragraph?}


% ROY (11/04/06):
% This does not seem to stand on its own.  For now I will simply leave
% the allision to this challenge as a point for the conclusion.
%
% \subsection{Comments}
% 
% A third source of false positives arises from application-level
% protocols that ensure memory is used correctly across multiple
% invocations of the module's message handler, but which cannot be
% validated modularly.

\subsection{A Memory Leak in SOS}
\label{ss:tale}

\begin{figure}[tp]
\begin{footnotesize}
\begin{verbatim}
mod_op = (sos_module_op_t*) ker_msg_take_data(msg);
if(mod_op == NULL) return -ENOMEM;
if(mod_op->op == MODULE_OP_INSMOD) {
    existing_module = ker_get_module(mod_op->mod_id);
    if(existing_module != NULL) {
        uint8_t ver = sos_read_header_byte(
                existing_module->header,
                offsetof(mod_header_t, version));
            if (ver < mod_op->version) {
                ker_unload_module(existing_module->pid, 
                        sos_read_header_byte(
                        existing_module->header,
                        offsetof(mod_header_t, version)));
            } else {
                return SOS_OK;
            }
        }
    ret = fetcher_request(KER_DFT_LOADER_PID,
            mod_op->mod_id,
            mod_op->version,
            entohs(mod_op->size),
            msg->saddr);
    s->pend = mod_op;
    ker_led(LED_RED_TOGGLE);
    return SOS_OK;
}
return SOS_OK;
\end{verbatim}
\end{footnotesize}
\label{fig:leak}
\caption{A memory leak in an SOS module.}
\end{figure}

This section examines the SOS loader, a core part of SOS that allows
users to dynamically add modules to a running system and that is
known to have caused stability problems for developers in the past.
We used the checker to see if such a tool could have eased development
pains.

In mid-October 2005 the block of code shown in Figure~\ref{fig:leak}
was checked into CVS as part of {\tt loader.c} and introduced a memory
leak into the loader.  All paths through this block of code leak the
{\tt mod\_op} pointer, which the module acquires ownership of through
{\tt ker\_msg\_take\_data}.  This code results in the following
warning from the checker:

\begin{footnotesize}
\begin{verbatim}
Error: Expression mod_op is not stored after instruction #line 125
mod_op = (sos_module_op_t *)ker_msg_take_data((unsigned char)18, msg);
\end{verbatim}
\end{footnotesize}

After three additional revisions that do not significantly modify or
fix the memory leak, a fourth revision was made in mid-December 2005.
This revision expands the functionality of {\tt loader.c} and breaks
the code up into smaller functions:

\begin{footnotesize}
\begin{verbatim}
sos_module_op_t *mod_op;
if (msg->saddr == ker_id() || s->pend) {
    return SOS_OK;
}
mod_op = (sos_module_op_t*) ker_msg_take_data(msg);
if(mod_op == NULL) return -ENOMEM;
switch(mod_op->op){
case MODULE_OP_INSMOD:
    return module_op_insmod(s,msg,mod_op);
case MODULE_OP_RMMOD:
    return module_op_rmmod(s,msg,mod_op);
}
return SOS_OK;
\end{verbatim}
\end{footnotesize}

This code again causes our checker to warn about the memory leak:

\begin{footnotesize}
\begin{verbatim}
Error: Expression mod_op is not stored after instruction #line 186
mod_op = (sos_module_op_t *)ker_msg_take_data((unsigned char)18, msg);
\end{verbatim}
\end{footnotesize}

Clearly {\tt mod\_op} is still being leaked if {\tt mod\_op->op} does
not find a matching case in the {\tt switch} statement.  Further,
adding the {\tt sos\_release} attribute to the third formal parameter
of the functions {\tt module\_op\_insmod} and {\tt module\_op\_rmmod}
and rerunning the checker reveals that both of these functions also
leak {\tt mod\_op}!

A day later, eight weeks after the memory leaks were first introduced,
these memory leaks were found and fixed:

\begin{footnotesize}
\begin{verbatim}
sos_module_op_t *mod_op;
if (msg->saddr == ker_id() || s->pend) {
    return SOS_OK;
}
mod_op = (sos_module_op_t*) ker_msg_take_data(msg);
if(mod_op == NULL) return -ENOMEM;
switch(mod_op->op){
case MODULE_OP_INSMOD:
    return module_op_insmod(s,msg,mod_op);
case MODULE_OP_RMMOD:
    return module_op_rmmod(s,msg,mod_op);
}
ker_free(mod_op);
return SOS_OK;
\end{verbatim}
\end{footnotesize}

As shown above, a call to {\tt ker\_free} has been added before the
final {\tt return}, in order to properly dispose of {\tt mod\_op}.
The functions {\tt module\_op\_insmod} and {\tt module\_op\_rmmod}
similarly free their third argument.  The CVS log message simply reads
``fixed another memory leak.''





