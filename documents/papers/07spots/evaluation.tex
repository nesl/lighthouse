\section{Evaluation}
\label{sec:eval}

We evaluated our tool using the public CVS archives of the SOS
operating system.  SOS applications are made up of user modules that
run on a core kernel supplied by the operating system.  In this
analysis we ran the checker on individual modules and parts of the SOS
kernel to examine its utility in locating bugs.  

\subsection{Quantifying Dynamic Memory Usage in SOS}

Of interest is the prevalence of dynamic memory operations in the SOS
applications.  The SOS API includes a number of functions that
manipulate memory.  These functions are used to allocate, free, and
transfer ownership of blocks of memory.  To quantify the use of these
functions within SOS, we examine the frequency of memory
manipulation functions by user modules. 

The CVS head from October 2006 reveals 36 modules totaling 5824 lines
of source code.  Within this sample there are 178 lines of code
calling a function that manipulates memory.  This is about one such
function call for every 32 lines of code.  Similarly, looking at all
historic version of all SOS modules reveals a similar density of
function calls.  These findings indicate that memory management has
been and continues to be an important part of resource management in
SOS.


\subsection{Validating SOS End-User Modules}

Next we ran our tool on all SOS end-user modules from the October 2006
head of the SOS CVS repository.  The goal of this experiment was to
demonstrate that the tool is practical for use as part of the standard
development cycle and to demonstrate its ability to locate errors in
real sensor-network software.  For this analysis, we only consider the
first occurrence of a particular bug withing a program, even if the bug
lasts through multiple consecutive versions of a particular module.


The checker can be easily added to the normal build process of a C
application.  It takes as input a preprocessed C file and generates
warnings similar to those generated at other stages of compilation.
The analysis generates two types of warnings:
%
\begin{description}
%
\item[Memory leak:] Source code neither stores, releases, nor frees
data that was taken or allocated.
%
\item[Dangling pointer:] Source code is accessing data that was
released or freed at an earlier point.
%
\end{description}


\begin{table}
\caption{Warnings in SOS user modules}
%
\label{tab:module}
\centering 
\begin{tabular}{| l | r |}
    \hline 
    Verified memory leaks identified by analysis & 8 \\
    \hline
    False memory leaks identified by analysis & 8 \\
    \hline 
    Verified dangling pointers identified by analysis & 0 \\
    \hline 
    False dangling pointers identified by analysis & 9 \\
    \hline 
\end{tabular} 
%
\end{table}

We applied the checker to every historic version of each user module
included in the SOS CVS repository that would compile for the
\code{mica2} target.  
%
Of the 213 historic versions of the 48 modules available, new warnings
appeared in 13 versions.  For this analysis we only counted the first
occurrence of a bug, even if it persisted through multiple versions of
a module.
%
An external configuration of 24 function annotations was used for this
analysis.  Additionally, local store annotations were added to 9
module versions and a change to the core SOS API from the summer of
2006 required changing the value of a constant in 6 module versions.


A total of 25 warnings were generated by the checker during this
experiment.  Each warning was examined by hand and classified as an
actual error or a false positive; the results are presented in
Table~\ref{tab:module}.  Eight of the warnings turned out to be real
memory leaks in the code.  An example memory leak from the code is
described at the end of this section.
%
The 17 remaining warnings were further classified to better
understand the sources of imprecision in the current implementation of
the checker.  


\smallskip\noindent{\bf Memory leak false positives.}

False positive memory leaks came from two different sources. Five of
the false positives resulted from a conservative assumption made by
the must alias analysis used within the checker.  The analysis assumes
that functions can change what data is referenced by a formal
parameter.  This results in the must alias information being lost in
these cases.  The analysis can easily rank these as probable false
positives if the end user wishes to see more likely errors first.

The other three memory leaks are the result of linked list data
structures that the must alias analysis is unable to properly reason
about.  

\smallskip\noindent{\bf Dangling pointer false positives.}

The nine dangling pointer false positives result from limitations of
the flow-insensitive and field-insensitive analysis.  A benefit of the
sensor network domain is the limited scope of program components.
This opens the door to using context sensitive analysis that suffer
from scaling limitations in more general domains.



\subsection{Validating the SOS Kernel}

\begin{table}
\caption{Warnings in the SOS kernel}
%
\label{tab:kernel}
\centering 
\begin{tabular}{| l | r |}
    \hline 
    Verified memory leaks identified by analysis & 2 \\
    \hline
    False memory leaks identified by analysis & 22 \\
    \hline 
    Verified dangling pointers identified by analysis & 0 \\
    \hline 
    False dangling pointers identified by analysis & 11 \\
    \hline 
    \hline 
\end{tabular} 
%
\end{table}


We ran a similar experiment on the SOS kernel.  We ran the checker on
the current version of all code required to build the core SOS kernel
with a simple ``blank'' application for the Mica2 hardware.  This
configuration consists of approximately 9000 lines of source code and required
analyzing 40 source files, of which 35 generated warnings.  A detailed
listing of these warnings is provided in table~\ref{tab:kernel}.

The two actual memory leaks represent an interesting type of error.
These leaks resulted from functions that would released a formal
parameter, except in exceptional cases where an error code is returned
to the user.  One could argue that these functions do not leak memory,
but rather conditionally release memory.  We opted for classifying
them as errors, since user code did not bother to check return values
for the conditional release of data.  We could have changed the
analysis to treat these functions as conditional releases.  In this
case the two functions would not have been found to be in error, but a
number of additional bugs would have been located in the user code.

A second point of interest are the different rates of false positives
reported for user modules and for the kernel.  User modules resulted
in approximately one false positive for every 1650 lines of source
code.  The kernel saw a much higher frequency at approximately one 
false positive for every 270 lines of source code.  

A large contributor to this increased rate of false positives within
the kernel are the ``bottom layer'' functions implementing management
of memory in SOS.  These functions manipulate memory in a manner that
does not conform to the model assumed for the analysis.  For example,
the function \code{ker\_msg\_take\_data} is annotated to denote that
it returns dynamically allocated memory.  When the analysis examines
the function to confirm that this is the case, it generates an error
declaring that the function does not return dynamically allocated
memory.  This is because the function directly accesses the internal
data structures of the SOS memory manager to return a pointer to
dynamically allocated data, rather than using an annotated interface
such as \code{ker\_malloc}.


% ROY (11/04/06):
% This does not seem to stand on its own.  For now I will simply leave
% the allision to this challenge as a point for the conclusion.
%
% \subsection{Comments}
% 
% A third source of false positives arises from application-level
% protocols that ensure memory is used correctly across multiple
% invocations of the module's message handler, but which cannot be
% validated modularly.

\subsection{A Memory Leak in SOS}
\label{ss:tale}

\begin{figure}[tp]
\begin{footnotesize}
\begin{verbatim}
mod_op = (sos_module_op_t*) ker_msg_take_data(msg);
if(mod_op == NULL) return -ENOMEM;
if(mod_op->op == MODULE_OP_INSMOD) {
    existing_module = ker_get_module(mod_op->mod_id);
    if(existing_module != NULL) {
        uint8_t ver = sos_read_header_byte(
                existing_module->header,
                offsetof(mod_header_t, version));
            if (ver < mod_op->version) {
                ker_unload_module(existing_module->pid, 
                        sos_read_header_byte(
                        existing_module->header,
                        offsetof(mod_header_t, version)));
            } else {
                return SOS_OK;
            }
        }
    ret = fetcher_request(KER_DFT_LOADER_PID,
            mod_op->mod_id,
            mod_op->version,
            entohs(mod_op->size),
            msg->saddr);
    s->pend = mod_op;
    ker_led(LED_RED_TOGGLE);
    return SOS_OK;
}
return SOS_OK;
\end{verbatim}
\end{footnotesize}
\label{fig:leak}
\caption{A memory leak in an SOS module.}
\end{figure}

This section examines the SOS loader, a core part of SOS that allows
users to dynamically add modules to a running system and that is
known to have caused stability problems for developers in the past.
We used the checker to see if such a tool could have eased development
pains.

In mid-October 2005 the block of code shown in Figure~\ref{fig:leak}
was checked into CVS as part of {\tt loader.c} and introduced a memory
leak into the loader.  All paths through this block of code leak the
{\tt mod\_op} pointer, which the module acquires ownership of through
{\tt ker\_msg\_take\_data}.  This code results in the following
warning from the checker:

\begin{footnotesize}
\begin{verbatim}
Error: Expression mod_op is not stored after instruction #line 125
mod_op = (sos_module_op_t *)ker_msg_take_data((unsigned char)18, msg);
\end{verbatim}
\end{footnotesize}

After three additional revisions that do not significantly modify or
fix the memory leak, a fourth revision was made in mid-December 2005.
This revision expands the functionality of {\tt loader.c} and breaks
the code up into smaller functions:

\begin{footnotesize}
\begin{verbatim}
sos_module_op_t *mod_op;
if (msg->saddr == ker_id() || s->pend) {
    return SOS_OK;
}
mod_op = (sos_module_op_t*) ker_msg_take_data(msg);
if(mod_op == NULL) return -ENOMEM;
switch(mod_op->op){
case MODULE_OP_INSMOD:
    return module_op_insmod(s,msg,mod_op);
case MODULE_OP_RMMOD:
    return module_op_rmmod(s,msg,mod_op);
}
return SOS_OK;
\end{verbatim}
\end{footnotesize}

This code again causes our checker to warn about the memory leak:

\begin{footnotesize}
\begin{verbatim}
Error: Expression mod_op is not stored after instruction #line 186
mod_op = (sos_module_op_t *)ker_msg_take_data((unsigned char)18, msg);
\end{verbatim}
\end{footnotesize}

Clearly {\tt mod\_op} is still being leaked if {\tt mod\_op->op} does
not find a matching case in the {\tt switch} statement.  Further,
adding the {\tt sos\_release} attribute to the third formal parameter
of the functions {\tt module\_op\_insmod} and {\tt module\_op\_rmmod}
and rerunning the checker reveals that both of these functions also
leak {\tt mod\_op}!

A day later, eight weeks after the memory leaks were first introduced,
these memory leaks were found and fixed:

\begin{footnotesize}
\begin{verbatim}
sos_module_op_t *mod_op;
if (msg->saddr == ker_id() || s->pend) {
    return SOS_OK;
}
mod_op = (sos_module_op_t*) ker_msg_take_data(msg);
if(mod_op == NULL) return -ENOMEM;
switch(mod_op->op){
case MODULE_OP_INSMOD:
    return module_op_insmod(s,msg,mod_op);
case MODULE_OP_RMMOD:
    return module_op_rmmod(s,msg,mod_op);
}
ker_free(mod_op);
return SOS_OK;
\end{verbatim}
\end{footnotesize}

As shown above, a call to {\tt ker\_free} has been added before the
final {\tt return}, in order to properly dispose of {\tt mod\_op}.
The functions {\tt module\_op\_insmod} and {\tt module\_op\_rmmod}
similarly free their third argument.  The CVS log message simply reads
``fixed another memory leak.''





