\section{Related Work}
\label{sec:related}

\subsection{Sensor Network Analysis Research}

As mentioned earlier, the memory manager in the SOS operating
system~\cite{sos} performs basic tracking of memory ownership to help
clean the system after module removal.
%
However, the burden remains on the end user to properly use the API
interacting with the memory manager, prevent memory leaks, and not
deference invalid pointers.
%
Our work grew out of a desire to prevent these kinds of errors from
occurring in SOS applications.



Dynamic checking of sensor network systems has become a popular technique to
improve system reliability and find system errors.
%
Recent work on Safe TinyOS and UTOS~\cite{regehr06memory} and software fault
isolation for embedded processors~\cite{kumar07system} uses static analysis
to insert run-time checks that ensure memory protection for sensor-network
systems.
%
Interface contract monitoring~\cite{archer07interface} interposes a thin
layer between interface clients and implementers, and has proved effective
in finding bugs in TinyOS programs.
%
These approaches provide valuable feedback to developers when an executing
system misbehaves.
%
In contrast to these works, the static analysis in Lighthouse focuses on
alerting developers to problems at compile time.



Other sensor network platforms include support for static checking targeting
other classes of errors.  
%
The nesC~\cite{nesC} language used in TinyOS employs a whole-program
analysis to statically detect race conditions.  
%
As another example, galsC~\cite{TinyGALS,galsC} employs an analysis to
ensure the type safety of connections between components.  



A complementary approach to improving the reliability of sensor network
software is through new language abstractions.  
%
For example, researchers have explored language support for component-based
programming~\cite{TinyOS,nesC,galsC}, region
abstractions~\cite{conf/mobisys/WhitehouseSCB04,conf/nsdi/WelshM04},
component composition~\cite{conf/sensys/GreensteinKE04}, and programming in
the aggregate~\cite{1052213,conf/dcoss/GummadiGG05}.
%
New language constructs enable easier expression of certain programming
idioms, often making programs more amenable to static checking.  
%
Our tool currently analyzes ordinary C programs, since that is the language
that SOS employs, but it would be interesting to explore ways to leverage
specialized language constructs to improve the tool's effectiveness.



\subsection{Traditional Systems Analysis Research}



Static analysis has long been used in traditional systems.
%
Of particular relation to Lighthouse is work that finds violations of simple
rules using compiler extensions~\cite{engler00checking} and follow up work
to infer the rules given a code base~\cite{kremenek06from}.
%
Lighthouse focuses on a different point on the design spectrum using explicit
specifications and a clear design discipline to provide maximum
understanding to program developers.



Recent work in the programming languages community explores the concept of
ownership types~\cite{ownership,ownership2,BoyapatiEtAl02,aliasjava} for
object-oriented languages. 
%
Ownership types designate an owner object for each object, and the static
type system ensures a form of confinement for each object with respect to
its owner.  
%
For example, a typical invariant guaranteed by ownership type systems is
that an object will only be accessed by its owner or by other objects owned
by the same owner.  
%
In this way, an object's owner forms a dynamic scope within which the object
is confined.  
%
Related work on confined types~\cite{confined1,confined2} provides a more
static form of confinement, in which an object is guaranteed not to escape a
particular static scope.



Our work provides a static notion of ownership analogous to that of confined
types:  all accesses to a given resource may only occur within the static
scope of its owning module.  
%
On a technical level, however, the foundation of our work is quite distinct
from that of both ownership types and confined types, as we rely on dataflow
analysis rather than on type systems.  
%
Our use of dataflow analysis is necessary in order to safely accommodate
dynamic transfer of ownership, which the systems described above lack.  
%
Ownership transfer is critical in practice for sensor network applications,
for example it is needed to properly account for split-phase operations.  
%
Although recent work has explored a form of transfer in the context of
ownership type systems~\cite{DBLP:conf/ecoop/BanerjeeN05}, that work
requires programmers to provide detailed assertions about ownership, and
these assertions are proved as part of a more general program specification
and verification framework.



There have been several proposals for a form of {\em unique} or {\em linear}
pointer~\cite{Boyland:2001:ABU,aliasjava,Wad90:linear}, which is guaranteed
to be the only reference to its referent.  
%
These systems sometimes include a form of transfer of uniqueness from one
pointer to another.
%
For example, a {\tt unique} pointer in AliasJava~\cite{aliasjava} can be
transferred as long as a dataflow analysis shows that the original pointer
is no longer accessed after the transfer.  
%
Our tool does not enforce a uniqueness requirement.
%
Instead, a resource may have any number of aliases from within its owning
component, which is less restrictive and sometimes necessary in practice.
%
%(the {\tt nextReceiveBuffer} alias in Figure~\ref{fig:genericbase} is a good
%example).
%  
At the same time, transfer is still safely allowed, as long as none of these
aliases are accessed after the transfer.



A language extension to C\# called Sing\# provides a {\em channel} construct
for message-based communication, and the Singularity operating system uses
Sing\# channels for communication among
processes~\cite{fahndrich06language}.  
%
Sing\# employs a type system for channels based on the Vault
language~\cite{Vault,adoption-focus}, which provides a sophisticated form of
linear types, to enforce ownership invariants on data buffers passed among
processes.  
%
This includes the use of programmer-defined channel {\em contracts} to
specify and check ownership transfer.
%
Lighthouse enforces a similar ownership discipline on dynamic memory in SOS,
but at a very different point in the design space.  
%
Rather than devising a new language and type system, our approach works
seamlessly with standard languages and tool chains for sensor-network
programming in a lightweight manner.  
%
Of course, a language solution like Sing\# has the potential to be more
expressive and to provide stronger guarantees, by enforcing a stylized
programming model.



Clouseau~\cite{heine03practical} develops a type system to statically ensure
that a dynamically allocated memory is freed exactly once in C and C++
programs.
%
The whole program analysis provided by Clouseau uses a constraint system to
track owning pointers both intra- and inter-procedurally, avoiding many of
the pointer analysis problems faced by Lighthouse.
%
In addition to the monitoring of memory leaks performed by Clouseau,
Lighthouse tracks the status of pointers through the program dataflow to
locate invalid pointer dereferences.
%
Lighthouse also uses explicit specifications to better support modular
analysis of individual user components, independent of the surrounding
system.

