\section{The Lighthouse Tool}
\label{sec:alg}



We have instantiated our approach to static checking of dynamic resource
management in Lighthouse, a tool for ensuring proper ownership of dynamic
memory in SOS programs.
%
The tool employs a suite of dataflow analyses to enforce the three rules
described in Section~\ref{subsec:owner} on each function.
%
This section overviews the usage and implementation of Lighthouse.


\subsection{Memory Ownership}
\label{subsec:owner}

Examination of the sensor network applications presented in
section~\ref{sec:mot} above reveals an underlying theme.  
%
In those examples, resources are shared dynamically across multiple software
components to support simple and efficient resource access.
%
However, only one component requires access to a given resource at any point
in time.  
%
In other words, proper resource management naturally obeys an {\em
ownership} discipline.  
%
In this style, each resource has a unique owning component (or {\em owner}),
who has the sole capability to access the resource.  
%
The owner also has the responsibility to eventually dispose of the resource
or explicitly {\em transfer} ownership to another component.



In this section we describe our approach for statically enforcing an
ownership discipline on sensor network applications.  
%
Lightweight annotations allow programmers to specify the ownership transfer
requirements of each function.  
%
For example, in Figure~\ref{fig:genericbase} the \code{receive} function
would be annotated to indicate that ownership of the \code{received}
parameter is being transferred from the caller to the callee, and that
ownership of the return value is being transferred from the callee to the
caller.  
%
Given these annotations, we define a static checker that can analyze each
function of a component in isolation, providing early and modular feedback
on the potential for resource management errors.



Informally, our static ownership discipline enforces the following rules:
%
\begin{enumerate}
%
\item Each function may only refer to dynamic memory that its component
owns.  This includes memory allocated in the function, memory in the
component's persistent store, and any formal parameters annotated as having
their ownership transferred to the component.
%
\item Each function that allocates or obtains ownership of a block of
dynamic memory must eventually free that memory, transfer its ownership to
another component, or store the memory in a persistent location.
%
\item After a function frees or releases memory that it owns, it may no
longer access the memory.
%
\end{enumerate}



Our rules are necessarily an approximation of the run time requirements for
proper resource ownership, due to the modular nature of the rules and the
fundamental limitations of static analysis.  
%
As described in the next section, the rules above can lead to both false
positives and false negatives.  
%
However, our experimental results indicate that the rules are a practical
approach for detecting resource management errors in real sensor network
software.



\subsection{TinyOS and SOS, Revisited}



The \code{receive} implementation in Figure~\ref{fig:genericbase} obeys our
static ownership discipline, assuming the annotations described above. 
%
Upon entry to the \code{receive} event handler the \code{GenericBaseM}
component owns the buffer referenced by the global variable \code{ourBuffer}
and gains ownership of the \code{received} buffer passed into the function.
%
Within the body of the function, these are the only two buffers accessed,
although they are at times accessed via the alias \code{nextReceiveBuffer}.  
%
If the message is able to be sent over the bridged interface, the function
returns the buffer originally referenced by \code{ourBuffer} and retains
ownership of \code{received} by storing it in \code{ourBuffer}.  
%
If the message is unable to be sent, the function returns the
\code{received} buffer, thereby giving up ownership and all references to
the buffer.



The ownership discipline also catches the potential errors that can be
introduced into \code{GenericBaseM}, as described earlier.  
%
Suppose that the programmer failed to update \code{ourBuffer} at line 11,
leading to a memory leak.  
%
In this case, the \code{receive} function fails to either free, transfer, or
persistently store \code{received}, violating our second rule above.
 


The SOS kernel already dynamically tracks memory ownership and has an
associated API for ownership transfer, which inspired our work.  
%
For example, the \code{SOS\_MSG\_RELEASE} flag in the call to
\code{post\_long} at line 14 in Figure~\ref{fig:surge} indicates that
ownership of \code{pkt} should be transferred to the callee (or freed by the
kernel if the callee does not explicitly take ownership).  
%
Similarly, the call to \code{ker\_msg\_take\_data} at line 20 allows the
caller to take ownership of \code{msg} under the alias \code{payload} (or to
take ownership of a copy of \code{msg}, if the message provider did not
explicitly release it).  
%
While useful as documentation, usage of this API is completely unchecked in
SOS, so programmers must manually ensure adherence to the implicit ownership
protocol associated with the API.  
%
Our work makes this protocol explicit and provides static checking for
conformance.



Given this API, the {\tt surge} module in Figure~\ref{fig:surge} can be seen
to adhere to our static ownership discipline.  
%
The \code{MSG\_DATA\_READY} message handler allocates \code{pkt}, thereby
taking initial ownership. 
%
This pointer is then dereferenced in order to provide the sensor data to be
sent up the routing tree.  
%
This pointer manipulation is safe since the module has ownership.  
%
The module then releases ownership by posting \code{pkt} to the tree routing
module using the \code{SOS\_MSG\_RELEASE} tag.  
%
After this release, the module does not access \code{pkt} again. 
%
The handler for \code{MSG\_TR\_DATA\_PKT} also conforms to the protocol.   
%
When the current node is the base station, the handler explicitly acquires
ownership of the message's data using \code{ker\_msg\_take\_data}.  
%
This allows the module to manipulate the data and to pass it to the UART.  
%
The \code{post\_net} call explicitly releases the data, fulfilling the
module's obligation to that data.
%
After the release, the data is no longer accessed.




Again, our static rules would catch changes to this code that cause dynamic
resource management errors.
%
For example, suppose the branch for \code{MSG\_DATA\_READY} did not release
ownership of \code{pkt} by setting the \code{SOS\_MSG\_RELEASE} flag in the
call to {\tt post\_long}, thereby retaining ownership but leaking the
memory.    
%
In this case, the code fails to either free, transfer, or persistently store
\code{pkt}, violating our second rule above.  
%
On the other hand, if the \code{SOS\_MSG\_RELEASE} flag is set but the code
accesses \code{pkt} after the call to \code{post\_long}, then the dangling
access is caught by our third rule.
 




\subsection{Ownership Annotations}


Lighthouse depends on programmer-specified {\em ownership annotations} to
specify when ownership of a block of memory should transfer from one
component to another.
%
These annotations provide a ``spec'' for each function, indicating its
preconditions and postconditions with respect to memory ownership.  
%
This spec then enables precise modular checking of functions.  
%
Each function body is checked to ensure the postconditions on exit, under
the assumption that the preconditions hold on entry.  
%
The function is also checked to obey the three rules constituting the
ownership discipline, defined earlier.  
%
Each caller is separately checked to ensure the callee's preconditions
before the call, and it may assume the callee's postconditions after the
call.



Two ownership annotations are used to describe changes of memory ownership
resulting from function calls: {\tt lh\_claim} and {\tt lh\_release}.
%
The {\tt lh\_claim} annotation states that the caller of the function will
take ownership of the memory pointed to by the annotated formal parameter or
annotated return value, and therefore that the function body must release
it.
%
For example, the SOS kernel's \code{ker\_malloc} function has the {\tt
lh\_claim} annotation on its return value, to indicate that it returns
dynamically allocated memory that the caller will own.
%
Conversely, the {\tt lh\_release} annotation states that the caller of the
function will release ownership of the memory pointed to by the annotated
formal parameter, and therefore that the function body must take ownership
of this memory.
%
For example, the formal parameter of the SOS kernel's \code{ker\_free}
function has the {\tt lh\_release} annotation.



Our ownership discipline defined earlier relies on the notion of a {\em
persistent store}:  each component is assumed to own the data in its
persistent store and can properly ``release'' owned data into this store.
%
All global and static variables declared with a component are assumed by the
analysis to be part of the component's persistent store.
%
A third and final annotation, {\tt lh\_store}, is used to denote formal
parameters of functions that can also be considered part of the persistent
store.
%
An example usage of {\tt lh\_store} is to annotate the \code{state}
parameter of a module's message handler in SOS.
%
As described earlier, this parameter points to the persistent store
allocated and maintained by the SOS kernel for a module.



Annotations typically reside in an external configuration file listing a
function name and the corresponding annotations for the return value and
formal parameters.
%
Only functions that require annotations need to be included within this
configuration file.
%
Annotations can also be included directly in the source code as GCC
attributes decorating the prototype of a function.
%
In practice we have found that a small set of annotations, \numannote for
the complete evaluation of SOS, is sufficient for precise analysis. 



The ability to perform checking modularly allows application writers to
obtain early feedback about the correctness of their resource management,
without requiring access to the rest of the system.  
%
This is particularly important in a system like SOS, in which modules can be
linked and unlinked dynamically.  
%
In such a setting, the ``rest'' of the system is a moving target, so it is
not really possible to consider an approach based on whole-program analysis.



\subsection{Implementation Overview}



Lighthouse is implemented in the CIL front end for C~\cite{CIL}, which
parses C code into a simple intermediate format and provides a framework for
performing analyses on the intermediate code. 
%
Lighthouse takes as input a preprocessed C file and prints out warning
messages similar to those produced by a C compiler when suspect code is
identified.
%
The analysis does not modify the preprocessed code, so it can be trivially
called from a makefile between the preprocessing and code generation stages
of compilation.



The Lighthouse analysis traverses each function's control-flow graph (CFG)
in isolation, which conservatively represents all possible execution paths
through the function.  
%
During this traversal, Lighthouse triggers two major dataflow analyses to
detect potential errors:



\begin{itemize}



\item Whenever a node in the graph is encountered that allocates or takes
ownership of a block of memory, Lighthouse invokes a dataflow analysis to
ensure that every path from this node to the function exit frees, stores, or
releases ownership of the memory exactly once.  
%
If this property is not satisfied, Lighthouse reports a possible memory
leak.



\item Whenever a node in the graph is encountered that frees or releases
ownership of a block of memory, Lighthouse invokes a dataflow analysis to
ensure that no path from this node to the function exit accesses the memory.  
%
If this property is not satisfied, Lighthouse reports a possible dangling
pointer error.



\end{itemize}



These two analyses also serve to check that a function meets its spec.  
%
For the purpose of the Lighthouse traversal over a function's CFG, the
function's entry node is considered an allocation point for all parameters
with the {\tt lh\_release} annotation, and the function's exit node is
considered a release point for all parameters and return values with the
{\tt lh\_claim} annotation.  



\subsection{Pointer Aliasing}



The analysis described above requires knowledge of the memory pointed to by
a function's pointers.  
%
As usual, this is statically approximated by an {\em alias analysis}, which
determines whether two different pointers store the same memory location at
a given program point.  
%
Two standard approximations to the true dynamic alias information are {\em
must-alias} analysis and {\em may-alias} analysis.  
%
A must-alias analysis underapproximates the dynamic alias relations:  if a
must-alias analysis determines that $x$ and $y$ alias at a particular
program point, then they definitely alias at that point in any program
execution.  
%
A may-alias analysis overapproximates the dynamic alias relations:  if a
may-alias analysis determines that $x$ and $y$ {\em cannot} alias at a
particular program point, then they definitely do not alias at that point in
any program execution.



Lighthouse requires both kinds of static alias approximations.  
%
In the first dataflow analysis described above, alias information is used to
ensure that something definitely happens, namely that an allocated resource
is eventually released.  
%
Therefore, in this case we approximate the true alias information with
must-alias information.  
%
In the second dataflow analysis described above, alias information is used
to ensure that something definitely does not happen, namely an access to a
released resource.  
%
Therefore, in this case we approximate the true alias information with
may-alias information.



We have built a simple flow-sensitive must-alias analysis for use by
Lighthouse.  
%
For the may-alias analysis, we use a fast flow-insensitive analysis provided
by the CIL framework.  
%
Obtaining precise alias information at compile time is notoriously
difficult, and this limitation is the principal cause of false positives for
our analysis.
%
For example, CIL's may-alias analysis does not distinguish among the fields
of a structure, instead considering them to always potentially alias one
another.  
%
Both alias analyses can be imprecise in the presence of linked data
structures.



\subsection{Limitations}



As we demonstrate in the next section, our checker is useful for detecting
violations of the ownership protocol on real sensor network code.  
%
However, the checker is not guaranteed to find all such violations.  
%
In other words, the checker can be used for finding memory errors but not
for guaranteeing the absence of all memory errors.  
%
The checker's false negatives come from three sources.



First, the checker does not precisely handle all of the unsafe features of
the C programming language.  
%
For example, pointer arithmetic is not statically analyzed.  
%
Instead, an expression of the form $p+i$, where $p$ is a pointer and $i$ is
an integer, is simply treated as if it refers to the same block of memory as
$p$.  
%
If $p+i$ in fact overflows to another block of memory at run time, the
checker's assumption can cause it to miss errors.  
%
These kinds of {\em memory safety} assumptions are standard for C-based
program analyses.



Second, there is a design choice about how to treat resource parameters that
are not annotated with {\tt lh\_release}.  Technically the ownership
protocol disallows these resources from being accessed at all, since the
receiving component is not the owner.  
%
Lighthouse does not currently enforce the requirement that a component only
access a resource that it owns.
% 
This design decision provides a seamless adoption path for Lighthouse on
existing systems.  
%
Programmers can incrementally add annotations to refine the quality of the
analysis without suffering from excessive numbers of false positives.
%
This decision also provides a mechanism for allowing patterns of resource
sharing that are in fact safe but not supported by the ownership discipline,
for example when a component temporarily ``borrows'' data from another
component within a bounded scope.
%
The cost of this flexibility is the potential to miss real resource
management errors.
%
However, the checker still ensures that a function does not access a
resource that has earlier been released by the function, thereby detecting
memory leaks.



Third, our modular checker does not consider the overall order in which
messages will be received by a component.  
%
However, event orderings can affect the correctness of ownership tracking
when a resource is accessed via the persistent store.
%
For example, consider a component that responds to three events: $\create$
causes the component to allocate a block $b$ and store it into the
component's persistent store, $\access$ causes the component to access block
$b$ via the store, and $\delete$ causes the component to deallocate block
$b$ from the store.  
%
The component avoids dangling accesses to $b$ and leaks of $b$ as long as
the temporal sequence of events follows the regular expression $($ $\alloc$
$\access^*$ $\delete$ $)^*$.  



Lighthouse currently only tracks data locally within each event handler.  
%
When performing this tracking, the tool assumes on entry that all data in
the persistent store is owned by the component.
%
The tool similarly considers a resource to be properly released when it is
placed in the persistent store.  
%
These assumptions allow each of the three event handlers in our example to
pass all checks.  
%
Nonetheless, dynamic memory errors can still happen, for example if an
$\access$ event ever occurs before the $\alloc$ event.  
%
Our assumptions provide a practical point in the design space that allows
each event handler to be usefully checked for local violations of the
ownership protocol.  
%
Handling inter-component relationships and application-level protocols is
something we plan to pursue in the future, leveraging recent work on {\em
interface synthesis} for software components~\cite{AlurPOPL05,HJM05}.

