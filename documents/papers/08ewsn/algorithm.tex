\section{The Lighthouse Tool}
\label{sec:alg}



A single theme of exclusive data ownership underlies the examples provided in
section~\ref{sec:mot}.
%
References to resources are passed between multiple components to support
simple and efficient resource access.
%
However, only one component accesses a given resource at any point in time.
%
The examples illustrate the {\em ownership} discipline prevalent in sensor
networks.
%
Each resources in this discipline has a unique owning component with the sole
capability to access the resource.
%
The owner also has the responsibility to eventually dispose of the resource or
explicitly transfer ownership to another component.



In this section we describe our approach to statically enforcing an exclusive
ownership discipline on sensor network applications.  
%
Informally, following rules guarantee conformance to this discipline:
%
\begin{enumerate}
%
\item Each function may only refer to owned dynamic memory.  This includes
memory allocated in the function, memory accessible to the function via
persistent stores, and any formal parameters transferring dynamic data
ownership to the component.
%
\item Each function allocating or obtaining ownership of dynamic memory must
eventually free that memory, transfer its ownership to another component, or
store the memory in a persistent location.
%
\item After freeing or releasing owned memory, a function may no longer access
the memory.
%
\end{enumerate}



\subsection{TinyOS and SOS, Revisited}



The \code{SendMsg} interface described in section~\ref{ssec:tinyos} clearly
follows the above three rules.
%
Each component initially owns any \code{TOS\_Msg} that it creates at compile
time.
%
Calls to the \code{send} command transfer ownership of the \code{TOS\_Msg}
from the component to the kernel, after which the component must not access
the message until ownership is regained via the \code{sendDone} event.
%
Interface contracts provide a means to verify these properties at runtime.
%
Our work describes a simple technique to move this checking to compile time.
 


The SOS kernel already dynamically tracks memory ownership and has an
associated API for ownership transfer, which inspired our work.  
%
Calls to the messaging API can specify the \code{SOS\_MSG\_RELEASE} flag to
signal that ownership of the posted message is to be transferred to the callee
(or freed by the kernel if the callee does not explicitly take ownership).  
%
Calls to \code{ker\_malloc}, \code{ker\_free}, and \code{ker\_msg\_take\_data}
are known to allocate, free, and transfer ownership of memory respectively.
%
Unfortunately, conformance to an exclusive ownership protocol is unchecked in
the SOS runtime and the source of numerous problems in developing code.
%
Our work makes this protocol explicit and provides static checking for
conformance.



\subsection{Owenrship Specification}


%  Use specification file
%  - documentation
%  - concise
%  - simlpe
%  - reusable
%  
%  Specification describes pre- and post- memory conditions for function
%  - full / empty
%  - formal / return / store
%  - Examples for malloc / free / post 
%  
%  Global store



Analyzing memory ownership requires understanding how underlying functions
manipulate memory ownership properties.
%
Our analysis uses a simple specification file documenting functions that
transfer memory ownership between components by describing preconditions and
postconditions, with respect to memory ownership, for the function.
%
Each function body is checked to ensure the postconditions on exit, under
the assumption that the preconditions hold on entry.  
%
Each call within a function is separately checked to ensure the callee's
preconditions before the call, and it assumes the callee's postconditions
after the call.



\begin{figure}[tp]
\begin{scriptsize}
\begin{verbatim}
ker_malloc.pre {}

ker_malloc.post {
    $return.full();
}

ker_free.pre {
    $1.full();
}

ker_free.post {
    $1.empty();
}
\end{verbatim}
\end{scriptsize}
\caption{\label{fig:spec}Sample specifications for \code{ker\_free} and
\code{ker\_malloc}}.
\end{figure}



A function specification describes preconditions and postconditions relating
to the dynamic memory refenced by expressions.
%
These preconditions and postconditions may describe the expression as
pointing to a \code{full} or \code{empty} memory buffer.
%
Expresions in a specification may be one or more of: 
%
\begin{itemize}
%
\item Formal variable identified by index in function prototype
%
\item Function return value identified by the keyword \code{return} (only
valid in postconditions)
%
\item Global variable identified by variable name
%
\end{itemize}
%
An expression denoted as \code{full} in the postcondition describes dynamic
memory that the caller of the function will take ownership of from the
callee, and therefore that the function body must release it.
%
An expression denoted as \code{full} in the preconditon describes memory
that the caller of the function releases to the callee, and therefore that
the function body must take ownership of this memory.
%
The \code{empty} denotion is used to describe expressions that are known to
be not valid pointers to dynamic memory.



Example specifications demonstrating these ideas are presented in 
Figure~\ref{fig:spec}.
%
The postcondition for \code{ker\_malloc} notes that the returned data the
caller of \code{ker\_malloc} must take ownership of.
%
The \code{ker\_free} function specifies that the first formal parameter
points to valid memory when the function is called, but that this data must
be released before the function returns.



\mynote{Roy: Check the status of how (if?) we mark the state variable of modules
as being a valid store in the current version of the checker, and the
version of the checker used for the evaluation.}
%
Our ownership discipline also uses the notion of a persistent store:  each
component is assumed to own the data in its persistent store and can safely
``release'' owned data into this store.
%
All global and static variables declared within a component are assumed by
the analysis to be part of the component's persistent store.
%
Stores are used to describe individual the state parameter used by a
module's message handler in SOS.
%
As described earlier, this parameter points to the persistent store
allocated and maintained by the SOS kernel for a module.



The specification resides in a single external configuration file.
%
Only functions requiring annotations need be included in the specifications.
%
In practice we have found that a small set of annotations, \numannote for
the complete evaluation of SOS, is sufficient for precise analysis. 



The specification allows modular checking since the side effects of
called functions is availible without leaving the text of a function being
verified.
%
The ability to perform checking modularly allows application writers to
obtain early feedback about the correctness of their resource management,
without requiring access to the rest of the system.  
%
This is particularly important in a system like SOS, in which modules can be
linked and unlinked dynamically.  
%
In such a setting, the ``rest'' of the system is a moving target, so it is
not really possible to consider an approach based on whole-program analysis.



\subsection{Implementation Overview}



Lighthouse is implemented in the CIL front end for C~\cite{CIL}, which
parses C code into a simple intermediate format and provides a framework for
performing analyses on the intermediate code. 
%
Lighthouse takes as input a preprocessed C file and prints out warning
messages similar to those produced by a C compiler when suspect code is
identified.
%
The analysis does not modify the preprocessed code, so it can be trivially
called from a makefile between the preprocessing and code generation stages
of compilation.



The Lighthouse uses a simple forward dataflow analysis to track the state of
all expressions that may alias dynamic memory within a function.
%
The dataflow ensures that:
%
\begin{itemize}
%
\item Whenever a node in the dataflow graph is encountered that allocates or
takes ownership of a block of memory, every path from this node to the
function exit frees, stores, or releases ownership of the memory exactly
once.  
%
If this property is not satisfied, Lighthouse reports a possible memory
leak.
%
\item Whenever a node in the graph is encountered that frees or releases
ownership of a block of memory, that no path from this node to the function
exit accesses the memory.  
%
If this property is not satisfied, Lighthouse reports a possible dangling
pointer error.
%
\end{itemize}
%
For the purpose of the Lighthouse traversal over a function's CFG, the
function's entry node is considered an allocation point for all parameters
denoted as \code{full} in the functions precondition specification, and the
function's exit nodes are considered release points for all parameters and
return values denoted as \code{full}.



The analysis described above requires knowledge of the memory pointed to by
a function's pointers.  
%
As usual, this is statically approximated by an alias analysis, which
determines whether two different pointers store the same memory location at
a given program point.  
%
Two standard approximations to the true dynamic alias information are {\em
must-alias} analysis and {\em may-alias} analysis.
%
We have built a simple flow-sensitive must-alias analysis for use by
Lighthouse.  
%
For the may-alias analysis, we use a fast flow-insensitive analysis provided
by the CIL framework.  
%
Obtaining precise alias information at compile time is notoriously
difficult, and this limitation is the principal cause of false positives for
our analysis.
%
For example, CIL's may-alias analysis does not distinguish among the fields
of a structure, instead considering them to always potentially alias one
another.  
%
Both alias analyses can be imprecise in the presence of linked data
structures.



%  A must-alias analysis underapproximates the dynamic alias relations:  if a
%  must-alias analysis determines that $x$ and $y$ alias at a particular
%  program point, then they definitely alias at that point in any program
%  execution.  
%  %
%  A may-alias analysis overapproximates the dynamic alias relations:  if a
%  may-alias analysis determines that $x$ and $y$ {\em cannot} alias at a
%  particular program point, then they definitely do not alias at that point in
%  any program execution.



%  Lighthouse requires both kinds of static alias approximations.  
%  %
%  In the first dataflow analysis described above, alias information is used to
%  ensure that something definitely happens, namely that an allocated resource
%  is eventually released.  
%  %
%  Therefore, in this case we approximate the true alias information with
%  must-alias information.  
%  %
%  In the second dataflow analysis described above, alias information is used
%  to ensure that something definitely does not happen, namely an access to a
%  released resource.  
%  %
%  Therefore, in this case we approximate the true alias information with
%  may-alias information.



\subsection{Limitations}



As we demonstrate in the next section, our checker is useful for detecting
violations of the ownership protocol on real sensor network code.  
%
However, the checker is not guaranteed to find all such violations.  
%
By favoring simplicity, scalability, and practicality, the checker allows some
false negatives.




First, we favored using a simple memory model at the cost of not precisely
handle all of the unsafe features of the C programming language.  
%
For example, pointer arithmetic is not statically analyzed.  
%
Instead, an expression of the form $p+i$, where $p$ is a pointer and $i$ is an
integer, is simply treated as if it refers to the same block of memory as $p$.  
%
If $p+i$ in fact overflows to another block of memory at run time, the
checker's assumption can cause it to miss errors.  
%
These kinds of memory safety assumptions are standard for C-based program
analyses.



Second, there is a design choice about how to treat dynamic memory referenced
by formal parameters without the \code{full} denotation.
%
Technically the ownership protocol disallows this memory from being accessed
at all, since the receiving component is not the owner.  
%
Lighthouse assumes a more practical stance by not enforcing the requirement
that a component only access a resource that it owns.
% 
%  This design decision provides a seamless adoption path for Lighthouse on
%  existing systems.  % Programmers can incrementally add annotations to
%  refine the quality of the analysis without suffering from excessive numbers
%  of false positives.
%
This decision 
%  also 
provides a mechanism for allowing patterns of resource sharing that are in
fact safe but not supported by the ownership discipline, for example when a
component temporarily ``borrows'' data from another component within a bounded
scope.
%
The cost of this flexibility is the potential to miss real resource management
errors.
%
However, the checker still ensures that a function does not access a resource
that has earlier been released by the function, thereby detecting memory
leaks.



Third, our modular checker does not consider the overall order in which
messages will be received by a component.  
%
However, event orderings can affect the correctness of ownership tracking
when a resource is accessed via the persistent store.
%
For example, consider a component that responds to three events: $\create$
causes the component to allocate a block $b$ and store it into the
component's persistent store, $\access$ causes the component to access block
$b$ via the store, and $\delete$ causes the component to deallocate block
$b$ from the store.  
%
The component avoids dangling accesses to $b$ and leaks of $b$ as long as
the temporal sequence of events follows the regular expression $($ $\alloc$
$\access^*$ $\delete$ $)^*$.  



Perfering a scalable analysis that only requires examining a single function
at a time, Lighthouse only tracks data locally within each event handler.  
%
When performing this tracking, the tool assumes on entry that all data in the
persistent store is owned by the component.
%
The tool similarly considers a resource to be properly released when it is
placed in the persistent store.  
%
These assumptions allow each of the three event handlers in our example to
pass all checks.  
%
Nonetheless, dynamic memory errors can still happen, for example if an
$\access$ event ever occurs before the $\alloc$ event.  
%
Our assumptions provide a practical point in the design space that allows each
event handler to be usefully checked for local violations of the ownership
protocol.  



We have explored and implemented a prototype system combining Lighthouse with
finite state machine (FSM) representation of the expected event orderings.
%
This allows tracking of persistant store state across event handlers, solving
the problem described above.
%
However, this requires pushing basic monitoring into the system runtime to
watch for invalid event firing orders.
%
More complete handling of inter-component relationships and application-level
protocols is something we plan to pursue in the future, leveraging recent work
on {\em interface synthesis} for software components~\cite{AlurPOPL05,HJM05}.

